package handlers

import (
	"2026champs/internal/app"
	"2026champs/internal/model"
	"encoding/json"
	"fmt"
	"math/rand"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

// GenerateRoomCode generates a random 6-character room code
func GenerateRoomCode() string {
	const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	rand.Seed(time.Now().UnixNano())
	code := make([]byte, 6)
	for i := range code {
		code[i] = charset[rand.Intn(len(charset))]
	}
	return string(code)
}

// CreateRoomRequest represents the request body for creating a room
type CreateRoomRequest struct {
	HostPlayerID string             `json:"hostPlayerId"`
	Settings     model.RoomSettings `json:"settings"`
}

// CreateRoom creates a new game room
func CreateRoom(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req CreateRoomRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		// Generate unique room code
		roomCode := GenerateRoomCode()

		// Ensure code is unique (simple retry, in production use better approach)
		ctx := r.Context()
		for i := 0; i < 10; i++ {
			existing, _ := app.RoomRepo.GetByCode(ctx, roomCode)
			if existing == nil {
				break
			}
			roomCode = GenerateRoomCode()
		}

		// Set defaults if not provided
		if req.Settings.MaxPlayers == 0 {
			req.Settings.MaxPlayers = 10
		}
		if req.Settings.TimePerQuestionSec == 0 {
			req.Settings.TimePerQuestionSec = 30
		}
		if req.Settings.Mode == "" {
			req.Settings.Mode = "realtime"
		}
		if req.Settings.QuestionSetID == "" {
			req.Settings.QuestionSetID = "default"
		}

		// Create room
		room := &model.Room{
			Code:            roomCode,
			Status:          model.RoomWaiting,
			HostPlayerID:    req.HostPlayerID,
			ActiveSessionID: "",
			Settings:        req.Settings,
			CreatedAt:       time.Now(),
		}

		if err := app.RoomRepo.Create(ctx, room); err != nil {
			http.Error(w, fmt.Sprintf("Failed to create room: %v", err), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(room)
	}
}

// JoinRoomRequest represents the request body for joining a room
type JoinRoomRequest struct {
	RoomCode   string `json:"roomCode"`
	PlayerName string `json:"playerName"`
}

// JoinRoom allows a player to join a room
func JoinRoom(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req JoinRoomRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if req.RoomCode == "" {
			http.Error(w, "Room code is required", http.StatusBadRequest)
			return
		}
		if req.PlayerName == "" {
			http.Error(w, "Player name is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()

		// Verify room exists
		room, err := app.RoomRepo.GetByCode(ctx, req.RoomCode)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to find room: %v", err), http.StatusInternalServerError)
			return
		}
		if room == nil {
			http.Error(w, "Room not found", http.StatusNotFound)
			return
		}

		// Check if room is full (simplified - would need to count players)
		// For now, we'll allow joining

		// Create player
		player := &model.Player{
			ID:       "", // Will be generated by repo
			RoomCode: req.RoomCode,
			Nickname: req.PlayerName,
			Score:    0,
			Rating:   0,
			JoinedAt: time.Now(),
		}

		if err := app.PlayerRepo.Create(ctx, player); err != nil {
			http.Error(w, fmt.Sprintf("Failed to create player: %v", err), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(player)
	}
}

// GetRoom retrieves a room by code
func GetRoom(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		code := vars["code"]

		if code == "" {
			http.Error(w, "Room code is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()
		room, err := app.RoomRepo.GetByCode(ctx, code)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to find room: %v", err), http.StatusInternalServerError)
			return
		}
		if room == nil {
			http.Error(w, "Room not found", http.StatusNotFound)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(room)
	}
}
