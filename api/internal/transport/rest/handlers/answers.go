package handlers

import (
	"2026champs/internal/app"
	"2026champs/internal/model"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

// SubmitAnswerRequest represents the request body for submitting an answer
type SubmitAnswerRequest struct {
	SessionID    string             `json:"sessionId"`
	PlayerID     string             `json:"playerId"`
	QuestionID   string             `json:"questionId"`
	RoundNumber  int                `json:"roundNumber"`
	Response     model.ResponseData `json:"response"`
	TimeTakenSec int                `json:"timeTakenSec"`
}

// SubmitAnswer handles answer submission
func SubmitAnswer(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req SubmitAnswerRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if req.SessionID == "" {
			http.Error(w, "Session ID is required", http.StatusBadRequest)
			return
		}
		if req.PlayerID == "" {
			http.Error(w, "Player ID is required", http.StatusBadRequest)
			return
		}
		if req.QuestionID == "" {
			http.Error(w, "Question ID is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()

		// Verify session exists
		session, err := app.SessionRepo.GetByID(ctx, req.SessionID)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to find session: %v", err), http.StatusInternalServerError)
			return
		}
		if session == nil {
			http.Error(w, "Session not found", http.StatusNotFound)
			return
		}
		if session.Status != model.SessionActive {
			http.Error(w, "Session is not active", http.StatusBadRequest)
			return
		}

		// Calculate basic points (simplified - no AI analysis yet)
		points := calculateBasicPoints(req.Response, req.TimeTakenSec)

		// Create answer
		answer := &model.Answer{
			ID:           "", // Will be generated by repo
			SessionID:    req.SessionID,
			PlayerID:     req.PlayerID,
			QuestionID:   req.QuestionID,
			RoundNumber:  req.RoundNumber,
			Response:     req.Response,
			Points:       points,
			TimeTakenSec: req.TimeTakenSec,
			IsSkipped:    false,
			AnsweredAt:   time.Now(),
		}

		// Save answer to database
		if err := app.AnswerRepo.Create(ctx, answer); err != nil {
			http.Error(w, fmt.Sprintf("Failed to save answer: %v", err), http.StatusInternalServerError)
			return
		}

		// Update player score
		player, err := app.PlayerRepo.GetByID(ctx, req.PlayerID)
		if err == nil && player != nil {
			player.Score += points.TotalPoints
			app.PlayerRepo.Update(ctx, player)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(answer)
	}
}

// calculateBasicPoints calculates points without AI (simplified version)
func calculateBasicPoints(response model.ResponseData, timeTakenSec int) model.PointsBreakdown {
	points := model.PointsBreakdown{
		SpeedPoints:   0,
		ClarityPoints: 0,
		InsightPoints: 0,
		StreakBonus:   0,
		TotalPoints:   10, // Base points
	}

	// Speed bonus (faster = more points, up to 20 points)
	if timeTakenSec < 5 {
		points.SpeedPoints = 20
	} else if timeTakenSec < 10 {
		points.SpeedPoints = 15
	} else if timeTakenSec < 15 {
		points.SpeedPoints = 10
	} else {
		points.SpeedPoints = 5
	}

	// Clarity bonus (based on response completeness)
	if response.Text != "" && len(response.Text) > 20 {
		points.ClarityPoints = 15
	} else if response.Text != "" {
		points.ClarityPoints = 10
	} else if response.SelectedOption != "" {
		points.ClarityPoints = 5
	}

	// Insight bonus (placeholder - would use AI)
	points.InsightPoints = 5

	points.TotalPoints = points.SpeedPoints + points.ClarityPoints + points.InsightPoints + points.StreakBonus + 10

	return points
}

// GetAnswersBySession retrieves all answers for a session
func GetAnswersBySession(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		sessionID := vars["sessionId"]

		if sessionID == "" {
			http.Error(w, "Session ID is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()
		answers, err := app.AnswerRepo.GetBySessionID(ctx, sessionID)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to get answers: %v", err), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(answers)
	}
}
