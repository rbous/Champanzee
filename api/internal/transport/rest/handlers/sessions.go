package handlers

import (
	"2026champs/internal/app"
	"2026champs/internal/model"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/gorilla/mux"
)

// StartSessionRequest represents the request body for starting a session
type StartSessionRequest struct {
	RoomCode string `json:"roomCode"`
}

// StartSession starts a new game session in a room
func StartSession(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var req StartSessionRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if req.RoomCode == "" {
			http.Error(w, "Room code is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()

		// Verify room exists
		room, err := app.RoomRepo.GetByCode(ctx, req.RoomCode)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to find room: %v", err), http.StatusInternalServerError)
			return
		}
		if room == nil {
			http.Error(w, "Room not found", http.StatusNotFound)
			return
		}

		// Create session
		session := &model.Session{
			ID:        "", // Will be generated by repo
			RoomCode:  req.RoomCode,
			Status:    model.SessionActive,
			StartedAt: time.Now(),
			EndedAt:   nil,
		}

		if err := app.SessionRepo.Create(ctx, session); err != nil {
			http.Error(w, fmt.Sprintf("Failed to create session: %v", err), http.StatusInternalServerError)
			return
		}

		// Cache session in Redis
		if err := app.SessionCache.Set(ctx, session); err != nil {
			// Log error but don't fail - caching is optional
			fmt.Printf("Warning: Failed to cache session: %v\n", err)
		}

		// Update room with active session
		room.ActiveSessionID = session.ID
		room.Status = model.RoomLive
		if err := app.RoomRepo.Update(ctx, room); err != nil {
			http.Error(w, fmt.Sprintf("Failed to update room: %v", err), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(session)
	}
}

// GetSession retrieves a session by ID
func GetSession(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		sessionID := vars["id"]

		if sessionID == "" {
			http.Error(w, "Session ID is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()

		// Try cache first
		session, err := app.SessionCache.Get(ctx, sessionID)
		if err == nil && session != nil {
			w.Header().Set("Content-Type", "application/json")
			json.NewEncoder(w).Encode(session)
			return
		}

		// Fallback to database
		session, err = app.SessionRepo.GetByID(ctx, sessionID)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to find session: %v", err), http.StatusInternalServerError)
			return
		}
		if session == nil {
			http.Error(w, "Session not found", http.StatusNotFound)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(session)
	}
}

// EndSessionRequest represents the request body for ending a session
type EndSessionRequest struct {
	SessionID string `json:"sessionId"`
}

// EndSession ends a game session
func EndSession(app *app.App) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		vars := mux.Vars(r)
		sessionID := vars["id"]

		if sessionID == "" {
			http.Error(w, "Session ID is required", http.StatusBadRequest)
			return
		}

		ctx := r.Context()

		// Get session
		session, err := app.SessionRepo.GetByID(ctx, sessionID)
		if err != nil {
			http.Error(w, fmt.Sprintf("Failed to find session: %v", err), http.StatusInternalServerError)
			return
		}
		if session == nil {
			http.Error(w, "Session not found", http.StatusNotFound)
			return
		}

		// Update session
		now := time.Now()
		session.Status = model.SessionEnded
		session.EndedAt = &now

		if err := app.SessionRepo.Update(ctx, session); err != nil {
			http.Error(w, fmt.Sprintf("Failed to update session: %v", err), http.StatusInternalServerError)
			return
		}

		// Remove from cache
		app.SessionCache.Delete(ctx, sessionID)

		// Update room
		room, err := app.RoomRepo.GetByCode(ctx, session.RoomCode)
		if err == nil && room != nil {
			room.ActiveSessionID = ""
			room.Status = model.RoomWaiting // Or RoomEnded if all sessions done
			app.RoomRepo.Update(ctx, room)
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(session)
	}
}
